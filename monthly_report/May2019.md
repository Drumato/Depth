# 05/04

字句解析からスタートして､加減算のアセンブリ生成まではやった｡

本当はRustで実装するつもりでいたけど､  
とにかくガンガン実装していきたかったので慣れているGoでやった｡  
加減算についてはコード書いてたので､いろいろ改良しながらほぼ転用｡

最適化については**追々やる**のが大事｡  
まだ中間表現の層も作っていないし(恐らく2､3段階に分けて生成すると思う)

明日はmain関数に載せるところまでをやる｡

# 05/05

main関数に載せたのと､中間表現の層を作った｡  
今作った中間表現はどちらかというとx86-64ニーモニックに対応する､  
いわば **アーキテクチャ固有**の中間表現に近い｡  

できればその前にSSA形式の層を作ってみたい｡  

## 中間表現に加えようと思っている要素

- 参照カウンタ
  - unusedな変数等の削除､Warning､コンパイルエラーとか出来る｡
- ライフタイム
  - Rustほど具体的な概念ではないけど､スコープの情報を持たせてもいいと思う｡

# 05/06

乗除算に対応して､取り敢えず四則演算については正しくコンパイル出来るように｡  
また､Return文を実装した｡  

後は`optlevel`ってオプションを作って､  
**値が2のとき** には結構最適化されたアセンブリを吐くように｡  

四則演算についてはかなり短いコードになる｡  
ただgccは既に畳み込まれた状態でコードが生成される｡  

具体的には､  

```c
int main(void){
  return 4+20+30+50;
  }
```

みたいなの書くと､  

```nasm
mov rax, 104
ret
```

とかなってる(まぁ `-O3` オプションつけるとだけど)｡  
これは恐らく中間表現をいくつか経由する中で畳み込まれるんだと思う｡  

**中間表現のステージ構成**については未だ何も考えていないけど､  
恐らく最適化のジャンル毎に分けるのがいい感じなのかも｡  コードの可読性も高まるし｡  

# 05/06

変数定義､条件式､if文を実装した｡  
